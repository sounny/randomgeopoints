<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Random Point Generator - Geospatial Sampling Tool</title>
  <meta name="description"
    content="Generate statistically valid random point samples for geospatial accuracy validation. Probability-based sampling with GeoJSON export.">
  <link rel="preconnect" href="https://unpkg.com" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: rgba(30, 41, 59, 0.85);
      --border: rgba(51, 65, 85, 0.5);
      --primary: #3b82f6;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --success: #10b981;
      --warning: #f59e0b;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-rows: auto 1fr;
      overflow: hidden;
    }

    .glass {
      background: var(--panel);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--border);
    }

    header {
      padding: 0.75rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 700;
      background: linear-gradient(90deg, #fff, #94a3b8);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #app {
      display: grid;
      grid-template-columns: 400px 1fr;
      height: 100%;
      overflow: hidden;
    }

    #controls {
      overflow-y: auto;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      border-right: 1px solid var(--border);
    }

    .section {
      display: grid;
      gap: 0.6rem;
    }

    .section h2 {
      margin: 0;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      font-weight: 600;
    }

    label {
      display: block;
      font-size: 0.8rem;
      font-weight: 500;
      margin-bottom: 0.2rem;
    }

    .help {
      font-size: 0.7rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    input,
    select,
    button {
      width: 100%;
      padding: 0.5rem 0.6rem;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 0.8rem;
      transition: all 0.2s;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .btn {
      cursor: pointer;
      font-weight: 600;
      text-align: center;
    }

    .btn:hover {
      filter: brightness(1.1);
    }

    .btn.primary {
      background: var(--primary);
      border: none;
      color: white;
    }

    .btn.good {
      background: var(--success);
      border: none;
      color: white;
    }

    .btn.outline {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
    }

    #map {
      height: 100%;
      width: 100%;
      z-index: 1;
    }

    details {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    details summary {
      padding: 0.6rem;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
    }

    details .inner {
      padding: 0.75rem;
      border-top: 1px solid var(--border);
    }

    .stats-card {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.2);
      border-radius: 6px;
      padding: 0.75rem;
    }

    .stats-val {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--success);
    }

    .stats-label {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .status-pill {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      background: rgba(16, 185, 129, 0.15);
      color: var(--success);
      border: 1px solid rgba(16, 185, 129, 0.3);
    }

    .drop-zone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
      transition: all 0.2s;
      cursor: pointer;
    }

    .drop-zone:hover,
    .drop-zone.dragover {
      border-color: var(--primary);
      background: rgba(59, 130, 246, 0.1);
    }

    .drop-zone.has-file {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
    }

    .strata-list {
      max-height: 150px;
      overflow-y: auto;
      display: grid;
      gap: 0.4rem;
    }

    .strata-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.4rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      font-size: 0.75rem;
    }

    .strata-item input {
      width: 70px;
      padding: 0.2rem 0.4rem;
    }

    .warning-banner {
      background: rgba(245, 158, 11, 0.15);
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 6px;
      padding: 0.6rem;
      font-size: 0.7rem;
      color: var(--warning);
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15, 23, 42, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      flex-direction: column;
      gap: 1rem;
    }

    .loading-overlay.active {
      display: flex;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
    <div class="help">Generating samples...</div>
  </div>

  <header>
    <div>
      <h1>Random Point Generator</h1>
      <div class="help">Probability-based geospatial sampling for accuracy validation</div>
    </div>
    <span class="status-pill" id="status">Ready</span>
  </header>

  <div id="app">
    <section id="controls" class="glass">

      <!-- Sampling Strategy -->
      <div class="section">
        <h2>Sampling Strategy</h2>
        <select id="method">
          <optgroup label="Simple Random">
            <option value="uniform-bbox">Uniform (Bounding Box)</option>
            <option value="uniform-poly">Uniform (Polygon/AOI)</option>
          </optgroup>
          <optgroup label="Systematic / Grid">
            <option value="systematic">Systematic Grid (Rectangular)</option>
            <option value="hex">Hexagonal Lattice</option>
            <option value="stratified">Stratified Grid (Jittered)</option>
            <option value="balanced">Spatially Balanced (Halton)</option>
          </optgroup>
          <optgroup label="Advanced">
            <option value="cluster">Cluster Sampling</option>
            <option value="poisson">Poisson Disk (Blue Noise)</option>
            <option value="stratified-prop">Stratified by Strata (Proportional)</option>
            <option value="stratified-equal">Stratified by Strata (Equal)</option>
            <option value="plots">Random Plots (Square)</option>
          </optgroup>
        </select>
      </div>

      <!-- AOI Definition -->
      <div class="section">
        <h2>Area of Interest (AOI)</h2>
        <div class="drop-zone" id="dropZone">
          <div>Drop AOI GeoJSON here or click</div>
          <input id="geojson" type="file" accept=".json,.geojson" style="display:none" />
        </div>
        <div class="help">Or define bounding box:</div>
        <div class="grid2">
          <input id="minx" type="number" step="any" placeholder="Min Lon" value="-82.6" />
          <input id="miny" type="number" step="any" placeholder="Min Lat" value="29.5" />
          <input id="maxx" type="number" step="any" placeholder="Max Lon" value="-82.1" />
          <input id="maxy" type="number" step="any" placeholder="Max Lat" value="29.9" />
        </div>
        <div class="grid2">
          <button class="btn outline" id="fitBbox">Fit Map</button>
          <button class="btn outline" id="drawRect">Draw AOI</button>
        </div>
      </div>

      <!-- Strata (Optional) -->
      <div class="section">
        <h2>Strata File (Optional)</h2>
        <div class="drop-zone" id="strataDropZone">
          <div>Drop strata GeoJSON here or click</div>
          <input id="strataFile" type="file" accept=".json,.geojson" style="display:none" />
        </div>
        <div id="strataConfig" style="display:none">
          <label>Property for strata ID:</label>
          <select id="strataField"></select>
          <div id="strataList" class="strata-list"></div>
        </div>
      </div>

      <!-- Parameters -->
      <div class="section">
        <h2>Parameters</h2>
        <div class="grid2">
          <div>
            <label>Total Points</label>
            <input id="npts" type="number" min="1" value="200" />
          </div>
          <div>
            <label>RNG Seed</label>
            <input id="seed" type="text" value="12345" />
          </div>
        </div>

        <details id="opt-grid">
          <summary>Grid Options</summary>
          <div class="inner">
            <label>Cell Size (degrees)</label>
            <input id="cell" type="number" step="0.001" value="0.02" />
          </div>
        </details>

        <details id="opt-cluster">
          <summary>Cluster Options</summary>
          <div class="inner grid2">
            <div>
              <label>Clusters</label>
              <input id="nClusters" type="number" value="10" min="1" />
            </div>
            <div>
              <label>Radius (m)</label>
              <input id="clusterRad" type="number" value="1000" />
            </div>
          </div>
        </details>

        <details id="opt-poisson">
          <summary>Poisson Options</summary>
          <div class="inner">
            <label>Min Distance (m)</label>
            <input id="mindist" type="number" value="500" />
          </div>
        </details>

        <details id="opt-plot">
          <summary>Plot Options</summary>
          <div class="inner">
            <label>Plot side (m)</label>
            <input id="plotSide" type="number" value="60" min="1" />
          </div>
        </details>
      </div>

      <button class="btn primary" id="run" style="padding:0.75rem; font-size:0.9rem">Generate Points</button>

      <!-- Results -->
      <div class="section">
        <h2>Results & Export</h2>
        <div class="grid2">
          <button class="btn good" id="downloadGeoJSON" disabled>Download GeoJSON</button>
          <button class="btn good" id="downloadCSV" disabled>Download CSV</button>
        </div>
        <div id="stats-area" class="stats-card" style="display:none">
          <div class="grid2">
            <div>
              <div class="stats-label">Samples</div>
              <div class="stats-val" id="pts-count">-</div>
            </div>
            <div>
              <div class="stats-label">AOI Area</div>
              <div class="stats-val" id="aoi-area">-</div>
            </div>
          </div>
          <div class="grid2" style="margin-top:0.5rem">
            <div>
              <div class="stats-label">NNI</div>
              <div class="stats-val" id="nni-val">-</div>
              <div class="help" id="nni-desc"></div>
            </div>
            <div>
              <div class="stats-label">Sample Density</div>
              <div class="stats-val" id="pt-density">-</div>
            </div>
          </div>
        </div>
        <div id="design-meta" class="stats-card" style="display:none; margin-top:0.5rem">
          <div class="stats-label">Design metadata</div>
          <div class="help" id="design-method"></div>
          <div class="help" id="design-unit"></div>
          <div class="help" id="design-weight"></div>
        </div>
      </div>

      <!-- Sample Size Calculator -->
      <details>
        <summary>Sample Size Calculator</summary>
        <div class="inner">
          <div class="help">Cochran's formula (95% CI)</div>
          <div class="grid2">
            <div>
              <label>Std. Error</label>
              <input id="calc-se" type="number" value="0.01" step="0.005" />
            </div>
            <div>
              <label>Exp. Accuracy</label>
              <input id="calc-p" type="number" value="0.85" step="0.05" />
            </div>
          </div>
          <button class="btn outline" id="calcSampleSize" style="margin-top:0.5rem">Calculate</button>
          <div id="calc-result" style="display:none; margin-top:0.5rem">
            <div class="stats-label">Recommended N:</div>
            <div class="stats-val" id="calc-n">-</div>
          </div>
        </div>
      </details>

      <!-- Warning -->
      <div class="warning-banner">
        <b>Note:</b> This tool generates sample locations based on probability sampling designs.
        It does not account for spatial autocorrelation. Ensure samples are sufficiently independent
        per Congalton (1988) guidelines.
      </div>

    </section>

    <div id="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    // ========== Utilities ==========
    function strToSeed(str) {
      let h = 1779033703 ^ str.length;
      for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return h >>> 0;
    }
    function mulberry32(a) {
      return function () {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }
    function randBetween(rng, min, max) { return min + (max - min) * rng(); }
    function snap6(x) { return Math.round(x * 1e6) / 1e6; }

    // ========== State ==========
    let polygonFC = null;
    let strataFC = null;
    let pointsFC = null;
    let designMeta = null;
    const status = msg => document.getElementById('status').textContent = msg;
    const showLoading = (show) => document.getElementById('loadingOverlay').classList.toggle('active', show);

    function toggleOptions() {
      const method = document.getElementById('method').value;
      document.getElementById('opt-grid').style.display = ['systematic', 'hex', 'stratified'].includes(method) ? 'block' : 'none';
      document.getElementById('opt-cluster').style.display = method === 'cluster' ? 'block' : 'none';
      document.getElementById('opt-poisson').style.display = method === 'poisson' ? 'block' : 'none';
      document.getElementById('opt-plot').style.display = method === 'plots' ? 'block' : 'none';
    }

    // ========== Map ==========
    const map = L.map('map').setView([29.65, -82.35], 10);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '(c) OpenStreetMap contributors' }).addTo(map);
    const aoiLayer = L.geoJSON(null, { style: { color: '#4cc9f0', weight: 2, fillOpacity: 0.1 } }).addTo(map);
    const strataLayer = L.geoJSON(null, { style: { color: '#f59e0b', weight: 1, fillOpacity: 0.15 } }).addTo(map);
    const ptsLayer = L.geoJSON(null, {
      pointToLayer: (f, latlng) => L.circleMarker(latlng, { radius: 4, weight: 1, color: '#34d399', fillColor: '#34d399', fillOpacity: 0.9 }),
      style: () => ({ color: '#22c55e', weight: 1.2, fillColor: '#22c55e', fillOpacity: 0.08 })
    }).addTo(map);

    // Draw control
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
    const drawControl = new L.Control.Draw({
      draw: { polygon: false, polyline: false, circle: false, marker: false, circlemarker: false, rectangle: true },
      edit: false
    });

    let drawMode = false;
    document.getElementById('drawRect').addEventListener('click', () => {
      if (!drawMode) {
        map.addControl(drawControl);
        drawMode = true;
        status('Draw a rectangle on the map');
      }
    });

    map.on(L.Draw.Event.CREATED, (e) => {
      drawnItems.clearLayers();
      drawnItems.addLayer(e.layer);
      const bounds = e.layer.getBounds();
      document.getElementById('minx').value = bounds.getWest().toFixed(6);
      document.getElementById('miny').value = bounds.getSouth().toFixed(6);
      document.getElementById('maxx').value = bounds.getEast().toFixed(6);
      document.getElementById('maxy').value = bounds.getNorth().toFixed(6);
      map.removeControl(drawControl);
      drawMode = false;
      status('Rectangle drawn - BBox updated');
    });

    // ========== Drop Zones ==========
    function setupDropZone(zoneId, fileInputId, onLoad) {
      const zone = document.getElementById(zoneId);
      const input = document.getElementById(fileInputId);

      zone.addEventListener('click', () => input.click());
      zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('dragover'); });
      zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
      zone.addEventListener('drop', (e) => {
        e.preventDefault();
        zone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) handleFile(file, zone, onLoad);
      });
      input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) handleFile(file, zone, onLoad);
      });
    }

    async function handleFile(file, zone, callback) {
      try {
        const txt = await file.text();
        const gj = JSON.parse(txt);
        zone.classList.add('has-file');
        zone.innerHTML = `<div>Loaded: ${file.name}</div>`;
        callback(gj);
      } catch (err) {
        alert('Failed to load: ' + err.message);
      }
    }

    setupDropZone('dropZone', 'geojson', (gj) => {
      const fc = gj.type === 'FeatureCollection' ? gj : { type: 'FeatureCollection', features: [gj] };
      const polys = { type: 'FeatureCollection', features: fc.features.filter(f => ['Polygon', 'MultiPolygon'].includes(f.geometry?.type)) };
      if (!polys.features.length) { alert('No polygons found'); return; }
      polygonFC = polys;
      aoiLayer.clearLayers();
      aoiLayer.addData(polys);
      map.fitBounds(aoiLayer.getBounds());
      status('AOI loaded');
    });

    setupDropZone('strataDropZone', 'strataFile', (gj) => {
      const fc = gj.type === 'FeatureCollection' ? gj : { type: 'FeatureCollection', features: [gj] };
      strataFC = fc;
      strataLayer.clearLayers();
      strataLayer.addData(fc);

      // Find all properties
      const allProps = new Set();
      fc.features.forEach(f => { if (f.properties) Object.keys(f.properties).forEach(k => allProps.add(k)); });

      const select = document.getElementById('strataField');
      select.innerHTML = '';
      allProps.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p;
        opt.textContent = p;
        select.appendChild(opt);
      });

      document.getElementById('strataConfig').style.display = 'block';
      updateStrataList();
      select.addEventListener('change', updateStrataList);
      status('Strata loaded');
    });

    document.getElementById('method').addEventListener('change', toggleOptions);
    toggleOptions();

    function updateStrataList() {
      if (!strataFC) return;
      const field = document.getElementById('strataField').value;
      const uniqueVals = [...new Set(strataFC.features.map(f => f.properties?.[field] || 'Unknown'))];
      const list = document.getElementById('strataList');
      list.innerHTML = '';
      uniqueVals.forEach(v => {
        const div = document.createElement('div');
        div.className = 'strata-item';
        div.innerHTML = `<span>${v}</span><input type="number" data-strata="${v}" value="50" min="1"/>`;
        list.appendChild(div);
      });
    }

    // ========== BBox ==========
    function parseBBox() {
      const vals = ['minx', 'miny', 'maxx', 'maxy'].map(id => parseFloat(document.getElementById(id).value));
      if (vals.some(isNaN)) throw new Error('Invalid bbox values');
      if (vals[0] >= vals[2] || vals[1] >= vals[3]) throw new Error('Min must be less than max');
      return vals;
    }

    document.getElementById('fitBbox').addEventListener('click', () => {
      try {
        const [minx, miny, maxx, maxy] = parseBBox();
        map.fitBounds([[miny, minx], [maxy, maxx]]);
        status('Map fit to bbox');
      } catch (err) { alert(err.message); }
    });

    function ensureAOI(bbox) {
      if (polygonFC?.features?.length) return polygonFC;
      return { type: 'FeatureCollection', features: [turf.bboxPolygon(bbox)] };
    }

    // ========== Sampling Methods ==========
    function uniformInBBox(n, bbox, rng) {
      const feats = [];
      for (let i = 0; i < n; i++) {
        const x = snap6(randBetween(rng, bbox[0], bbox[2]));
        const y = snap6(randBetween(rng, bbox[1], bbox[3]));
        feats.push(turf.point([x, y], { i: i + 1, method: 'uniform-bbox' }));
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function uniformInPolygon(n, polyFC, rng) {
      const bbox = turf.bbox(polyFC);
      const feats = [];
      let tries = 0;
      while (feats.length < n && tries < n * 2000) {
        tries++;
        const x = randBetween(rng, bbox[0], bbox[2]);
        const y = randBetween(rng, bbox[1], bbox[3]);
        const pt = turf.point([x, y]);
        if (turf.booleanPointInPolygon(pt, polyFC)) {
          feats.push(turf.point([snap6(x), snap6(y)], { i: feats.length + 1, method: 'uniform-poly' }));
        }
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function systematicGrid(n, polyFC, cellDeg) {
      const bbox = turf.bbox(polyFC);
      const pts = [];
      for (let x = bbox[0]; x <= bbox[2]; x += cellDeg) {
        for (let y = bbox[1]; y <= bbox[3]; y += cellDeg) {
          pts.push([x, y]);
        }
      }
      const inside = pts.filter(p => turf.booleanPointInPolygon(turf.point(p), polyFC));
      return { type: 'FeatureCollection', features: inside.map((p, i) => turf.point([snap6(p[0]), snap6(p[1])], { i: i + 1, method: 'systematic' })) };
    }

    function hexLattice(n, polyFC, cellDeg) {
      const bbox = turf.bbox(polyFC);
      const pts = [];
      const dy = cellDeg * Math.sqrt(3) / 2;
      let row = 0;
      for (let y = bbox[1]; y <= bbox[3]; y += dy) {
        const xStart = bbox[0] + (row % 2 ? cellDeg / 2 : 0);
        for (let x = xStart; x <= bbox[2]; x += cellDeg) pts.push([x, y]);
        row++;
      }
      const inside = pts.filter(p => turf.booleanPointInPolygon(turf.point(p), polyFC));
      const step = Math.max(1, Math.floor(inside.length / n));
      const picked = inside.filter((_, i) => i % step === 0).slice(0, n);
      return { type: 'FeatureCollection', features: picked.map((p, i) => turf.point([snap6(p[0]), snap6(p[1])], { i: i + 1, method: 'hex' })) };
    }

    function stratifiedJitter(n, polyFC, rng, cellDeg) {
      const bbox = turf.bbox(polyFC);
      const cells = [];
      for (let x = bbox[0]; x < bbox[2]; x += cellDeg) {
        for (let y = bbox[1]; y < bbox[3]; y += cellDeg) cells.push([x, y]);
      }
      for (let i = cells.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [cells[i], cells[j]] = [cells[j], cells[i]];
      }
      const feats = [];
      for (const [x0, y0] of cells) {
        if (feats.length >= n) break;
        const px = randBetween(rng, x0, x0 + cellDeg);
        const py = randBetween(rng, y0, y0 + cellDeg);
        if (turf.booleanPointInPolygon(turf.point([px, py]), polyFC)) {
          feats.push(turf.point([snap6(px), snap6(py)], { i: feats.length + 1, method: 'stratified' }));
        }
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function clusterSampling(n, polyFC, rng, nClusters, radiusM) {
      const centers = uniformInPolygon(nClusters, polyFC, rng).features;
      const feats = [];
      const ptsPerCluster = Math.ceil(n / centers.length);
      centers.forEach((c, idx) => {
        for (let i = 0; i < ptsPerCluster && feats.length < n; i++) {
          const [cx, cy] = c.geometry.coordinates;
          const mpdLat = 111320;
          const mpdLon = 111320 * Math.cos(cy * Math.PI / 180);
          const r = radiusM * Math.sqrt(rng());
          const theta = rng() * 2 * Math.PI;
          const nx = cx + (r * Math.cos(theta)) / mpdLon;
          const ny = cy + (r * Math.sin(theta)) / mpdLat;
          feats.push(turf.point([snap6(nx), snap6(ny)], { i: feats.length + 1, cluster: idx + 1, method: 'cluster' }));
        }
      });
      return { type: 'FeatureCollection', features: feats };
    }

    function poissonDisk(n, polyFC, rng, minDistM) {
      const bbox = turf.bbox(polyFC);
      const midLat = (bbox[1] + bbox[3]) / 2;
      const mpd = 111320 * Math.cos(midLat * Math.PI / 180);
      const minDistDegX = minDistM / mpd;
      const minDistDegY = minDistM / 111320;
      const pts = [];

      // Simple poisson-like
      let tries = 0;
      while (pts.length < n && tries < n * 100) {
        tries++;
        const x = randBetween(rng, bbox[0], bbox[2]);
        const y = randBetween(rng, bbox[1], bbox[3]);
        if (!turf.booleanPointInPolygon(turf.point([x, y]), polyFC)) continue;
        let tooClose = false;
        for (const p of pts) {
          const dx = (x - p[0]) / minDistDegX;
          const dy = (y - p[1]) / minDistDegY;
          if (dx * dx + dy * dy < 1) { tooClose = true; break; }
        }
        if (!tooClose) pts.push([x, y]);
      }
      return { type: 'FeatureCollection', features: pts.map((p, i) => turf.point([snap6(p[0]), snap6(p[1])], { i: i + 1, method: 'poisson' })) };
    }

    function stratifiedByStrata(n, strataFC, rng, mode) {
      const field = document.getElementById('strataField').value;
      const inputs = document.querySelectorAll('#strataList input');
      const allocations = {};
      inputs.forEach(inp => { allocations[inp.dataset.strata] = parseInt(inp.value) || 50; });

      const feats = [];
      strataFC.features.forEach(f => {
        const stratumName = f.properties?.[field] || 'Unknown';
        let count = mode === 'equal' ? Math.ceil(n / strataFC.features.length) : (allocations[stratumName] || 50);
        const stratumFC = { type: 'FeatureCollection', features: [f] };
        const pts = uniformInPolygon(count, stratumFC, rng).features;
        pts.forEach(p => {
          p.properties.stratum = stratumName;
          p.properties.method = mode === 'equal' ? 'stratified-equal' : 'stratified-prop';
        });
        feats.push(...pts);
      });
      feats.forEach((f, i) => f.properties.i = i + 1);
      return { type: 'FeatureCollection', features: feats.slice(0, n) };
    }

    function halton(index, base) {
      let result = 0;
      let f = 1 / base;
      let i = index;
      while (i > 0) {
        result += f * (i % base);
        i = Math.floor(i / base);
        f = f / base;
      }
      return result;
    }

    function spatiallyBalancedHalton(n, polyFC, rng) {
      const bbox = turf.bbox(polyFC);
      const feats = [];
      let idx = Math.floor(rng() * 1000) + 1;
      let attempts = 0;
      while (feats.length < n && attempts < n * 500) {
        const hx = halton(idx, 2);
        const hy = halton(idx, 3);
        const x = bbox[0] + (bbox[2] - bbox[0]) * hx;
        const y = bbox[1] + (bbox[3] - bbox[1]) * hy;
        const pt = turf.point([x, y]);
        if (turf.booleanPointInPolygon(pt, polyFC)) {
          feats.push(turf.point([snap6(x), snap6(y)], { i: feats.length + 1, method: 'balanced' }));
        }
        idx++;
        attempts++;
      }
      return { type: 'FeatureCollection', features: feats, attempts };
    }

    function randomPlots(n, polyFC, rng, sideM) {
      const bbox = turf.bbox(polyFC);
      const midLat = (bbox[1] + bbox[3]) / 2;
      const degPerMlon = 1 / (111320 * Math.cos(midLat * Math.PI / 180));
      const degPerMlat = 1 / 111320;
      const halfX = (sideM / 2) * degPerMlon;
      const halfY = (sideM / 2) * degPerMlat;
      const plots = [];
      let tries = 0;
      while (plots.length < n && tries < n * 600) {
        tries++;
        const cx = randBetween(rng, bbox[0], bbox[2]);
        const cy = randBetween(rng, bbox[1], bbox[3]);
        const center = turf.point([cx, cy]);
        if (!turf.booleanPointInPolygon(center, polyFC)) continue;
        const ring = [
          [snap6(cx - halfX), snap6(cy - halfY)],
          [snap6(cx + halfX), snap6(cy - halfY)],
          [snap6(cx + halfX), snap6(cy + halfY)],
          [snap6(cx - halfX), snap6(cy + halfY)],
          [snap6(cx - halfX), snap6(cy - halfY)],
        ];
        const cornersInside = ring.slice(0, 4).every(c => turf.booleanPointInPolygon(turf.point(c), polyFC));
        if (!cornersInside) continue;
        const poly = turf.polygon([ring], { i: plots.length + 1, method: 'plots', plotSideM: sideM });
        plots.push(poly);
      }
      return { type: 'FeatureCollection', features: plots, attempts: tries };
    }

    function computeStratumAreas(strataFC, field) {
      const out = {};
      if (!strataFC) return out;
      strataFC.features.forEach(f => {
        const key = f.properties?.[field] || 'Unknown';
        out[key] = (out[key] || 0) + turf.area(f);
      });
      return out;
    }

    function annotateDesign(fc, opts) {
      if (!fc?.features?.length) return null;
      const unitType = fc.features[0].geometry.type === 'Polygon' ? 'plot' : 'point';
      const meta = {
        method: opts.method,
        unitType,
        aoiAreaSqM: opts.aoiAreaSqM,
        seed: opts.seed,
        weightRule: '',
        stratumAreasSqM: null,
        attempts: opts.attempts || null
      };
      const n = fc.features.length;

      if (opts.method === 'stratified-prop' || opts.method === 'stratified-equal') {
        const field = opts.strataField;
        const areas = computeStratumAreas(opts.strataFC, field);
        const counts = {};
        fc.features.forEach(f => {
          const s = f.properties?.stratum || 'Unknown';
          counts[s] = (counts[s] || 0) + 1;
        });
        fc.features.forEach(f => {
          const s = f.properties?.stratum || 'Unknown';
          const weight = areas[s] ? areas[s] / counts[s] : opts.aoiAreaSqM / n;
          f.properties.weightAreaSqM = weight;
          f.properties.inclusionProb = counts[s] ? 1 / counts[s] : null;
          f.properties.unit = unitType;
        });
        meta.stratumAreasSqM = areas;
        meta.weightRule = 'Weights = stratum area / samples in stratum (assumes equal-probability within strata).';
      } else {
        const weight = opts.aoiAreaSqM / n;
        fc.features.forEach(f => {
          f.properties.weightAreaSqM = weight;
          f.properties.inclusionProb = 1 / n;
          f.properties.unit = unitType;
        });
        meta.weightRule = 'Equal probability; weightAreaSqM = AOI area / sample count.';
      }

      if (unitType === 'plot') {
        fc.features.forEach(f => {
          f.properties.plotAreaSqM = turf.area(f);
        });
      }

      return meta;
    }

    // ========== NNI ==========
    function calculateNNI(fc) {
      if (!fc || fc.features.length < 2) return { val: '-', desc: 'N/A' };
      const area = polygonFC ? turf.area(polygonFC) : turf.area(turf.bboxPolygon(parseBBox()));
      const n = fc.features.length;
      if (n > 2000) return { val: '-', desc: 'Too many pts' };

      const features = fc.features.map(f => f.geometry.type === 'Point' ? f : turf.centroid(f));
      const density = n / area;
      const expMean = 0.5 / Math.sqrt(density);
      let sum = 0;
      for (let i = 0; i < n; i++) {
        let minD = Infinity;
        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          const d = turf.distance(features[i], features[j], { units: 'meters' });
          if (d < minD) minD = d;
        }
        sum += minD;
      }
      const obsMean = sum / n;
      const nni = obsMean / expMean;
      let desc = 'Random';
      if (nni < 0.9) desc = 'Clustered';
      if (nni > 1.1) desc = 'Dispersed';
      return { val: nni.toFixed(2), desc };
    }

    function updateDesignPanel(meta, aoiAreaKm2) {
      const panel = document.getElementById('design-meta');
      if (!meta) {
        panel.style.display = 'none';
        return;
      }
      panel.style.display = 'block';
      document.getElementById('design-method').textContent = `Method: ${meta.method} | Unit: ${meta.unitType}`;
      document.getElementById('design-unit').textContent = `AOI area: ${aoiAreaKm2.toFixed(2)} km^2`;
      let weightLine = meta.weightRule;
      if (meta.attempts) weightLine += ` Attempts: ${meta.attempts}.`;
      if (meta.stratumAreasSqM) {
        const names = Object.keys(meta.stratumAreasSqM);
        if (names.length) weightLine += ` Strata tracked: ${names.slice(0, 3).join(', ')}${names.length > 3 ? '...' : ''}`;
      }
      document.getElementById('design-weight').textContent = weightLine;
    }

    // ========== Run ==========
    document.getElementById('run').addEventListener('click', () => {
      const method = document.getElementById('method').value;
      const n = Math.max(1, parseInt(document.getElementById('npts').value) || 200);
      const rng = mulberry32(strToSeed(document.getElementById('seed').value || 'seed'));
      const cell = parseFloat(document.getElementById('cell').value) || 0.02;
      const nClusters = parseInt(document.getElementById('nClusters').value) || 10;
      const clusterRad = parseFloat(document.getElementById('clusterRad').value) || 1000;
      const mindist = parseFloat(document.getElementById('mindist').value) || 500;
      const plotSide = parseFloat(document.getElementById('plotSide').value) || 60;

      let bbox;
      try { bbox = parseBBox(); } catch (e) { alert(e.message); return; }
      const polyFC = ensureAOI(bbox);
      const aoiAreaSqM = turf.area(polyFC);

      showLoading(true);
      status('Generating...');
      designMeta = null;

      setTimeout(() => {
        try {
          let out;
          if (method === 'uniform-bbox') out = uniformInBBox(n, bbox, rng);
          else if (method === 'uniform-poly') out = uniformInPolygon(n, polyFC, rng);
          else if (method === 'systematic') out = systematicGrid(n, polyFC, cell);
          else if (method === 'hex') out = hexLattice(n, polyFC, cell);
          else if (method === 'stratified') out = stratifiedJitter(n, polyFC, rng, cell);
          else if (method === 'cluster') out = clusterSampling(n, polyFC, rng, nClusters, clusterRad);
          else if (method === 'balanced') out = spatiallyBalancedHalton(n, polyFC, rng);
          else if (method === 'poisson') out = poissonDisk(n, polyFC, rng, mindist);
          else if (method === 'plots') out = randomPlots(n, polyFC, rng, plotSide);
          else if (method === 'stratified-prop' || method === 'stratified-equal') {
            if (!strataFC) { alert('Upload strata file first'); showLoading(false); return; }
            out = stratifiedByStrata(n, strataFC, rng, method === 'stratified-equal' ? 'equal' : 'prop');
          }

          if (!out?.features?.length) {
            alert('No samples generated');
            showLoading(false);
            return;
          }

          pointsFC = out;
          designMeta = annotateDesign(pointsFC, {
            method,
            aoiAreaSqM,
            seed: document.getElementById('seed').value,
            strataField: document.getElementById('strataField').value,
            strataFC,
            attempts: out.attempts
          });
          ptsLayer.clearLayers();
          ptsLayer.addData(out);
          map.fitBounds(ptsLayer.getBounds(), { maxZoom: 14 });
          aoiLayer.clearLayers();
          aoiLayer.addData(polyFC);

          // Stats
          const aoiArea = aoiAreaSqM / 1e6;
          const nni = calculateNNI(pointsFC);
          document.getElementById('stats-area').style.display = 'block';
          document.getElementById('pts-count').textContent = pointsFC.features.length;
          document.getElementById('aoi-area').textContent = aoiArea.toFixed(2) + ' km^2';
          document.getElementById('pt-density').textContent = (pointsFC.features.length / aoiArea).toFixed(1) + ' / km^2';
          document.getElementById('nni-val').textContent = nni.val;
          document.getElementById('nni-desc').textContent = nni.desc;
          updateDesignPanel(designMeta, aoiArea);

          document.getElementById('downloadGeoJSON').disabled = false;
          document.getElementById('downloadCSV').disabled = false;
          const statusMsg = pointsFC.features.length === n ? `Done: ${pointsFC.features.length} samples` : `Done: ${pointsFC.features.length}/${n} samples (inside AOI)`;
          status(statusMsg);
        } catch (err) {
          alert('Error: ' + err.message);
          status('Error');
        }
        showLoading(false);
      }, 100);
    });

    // ========== Sample Size Calculator ==========
    document.getElementById('calcSampleSize').addEventListener('click', () => {
      const se = parseFloat(document.getElementById('calc-se').value) || 0.01;
      const p = parseFloat(document.getElementById('calc-p').value) || 0.85;
      const Z = 1.96;
      const n = Math.ceil((Z * Z * p * (1 - p)) / (se * se));
      document.getElementById('calc-result').style.display = 'block';
      document.getElementById('calc-n').textContent = n;
    });

    // ========== Exports ==========
    function downloadFile(name, content, mime) {
      const blob = new Blob([content], { type: mime });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    document.getElementById('downloadGeoJSON').addEventListener('click', () => {
      if (!pointsFC) return;
      const data = {
        ...pointsFC,
        metadata: {
          generated: new Date().toISOString(),
          seed: document.getElementById('seed').value,
          method: designMeta?.method || document.getElementById('method').value,
          unit: designMeta?.unitType || 'point',
          count: pointsFC.features.length,
          aoiAreaSqM: designMeta?.aoiAreaSqM,
          weightRule: designMeta?.weightRule,
          stratumAreasSqM: designMeta?.stratumAreasSqM || null
        }
      };
      downloadFile('random_samples.geojson', JSON.stringify(data, null, 2), 'application/geo+json');
    });

    document.getElementById('downloadCSV').addEventListener('click', () => {
      if (!pointsFC) return;
      const rows = [['id', 'lon', 'lat', 'method', 'unit', 'stratum', 'cluster', 'weightAreaSqM', 'inclusionProb', 'plotAreaSqM', 'geometry']];
      pointsFC.features.forEach(f => {
        const geom = f.geometry;
        let lon = '';
        let lat = '';
        if (geom.type === 'Point') {
          lon = geom.coordinates[0];
          lat = geom.coordinates[1];
        } else {
          const c = turf.centroid(f);
          lon = snap6(c.geometry.coordinates[0]);
          lat = snap6(c.geometry.coordinates[1]);
        }
        rows.push([
          f.properties.i,
          lon,
          lat,
          f.properties.method,
          f.properties.unit || '',
          f.properties.stratum || '',
          f.properties.cluster || '',
          f.properties.weightAreaSqM || '',
          f.properties.inclusionProb ?? '',
          f.properties.plotAreaSqM || '',
          JSON.stringify(geom)
        ]);
      });
      const csv = rows.map(r => r.map(val => {
        const s = val === null || val === undefined ? '' : String(val);
        return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
      }).join(',')).join('\n');
      downloadFile('random_samples.csv', csv, 'text/csv');
    });

    // Init
    try {
      const [minx, miny, maxx, maxy] = parseBBox();
      map.fitBounds([[miny, minx], [maxy, maxx]]);
    } catch (e) { }
  </script>
</body>

</html>
