<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Random GeoPoints â€” Geospatial Sampling Workbench</title>
  <meta name="description"
    content="Advanced geospatial sampling and accuracy assessment tool. Generate probability-based samples, define protocols, and calculate Olofsson accuracy metrics.">
  <link rel="preconnect" href="https://unpkg.com" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    /* ========== Theme Variables ========== */
    :root {
      /* Light Theme (default) */
      --bg: #f8fafc;
      --bg-alt: #ffffff;
      --panel: rgba(255, 255, 255, 0.95);
      --border: rgba(148, 163, 184, 0.3);
      --primary: #0d9488;
      --primary-hover: #0f766e;
      --text: #1e293b;
      --text-muted: #64748b;
      --success: #059669;
      --warning: #d97706;
      --danger: #dc2626;
      --accent: #7c3aed;
      --point-color: #7c3aed;
      --header-bg: #0f172a;
      --header-text: #f8fafc;
    }

    [data-theme="dark"] {
      --bg: #0f172a;
      --bg-alt: #1e293b;
      --panel: rgba(30, 41, 59, 0.95);
      --border: rgba(71, 85, 105, 0.5);
      --primary: #14b8a6;
      --primary-hover: #2dd4bf;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --accent: #a78bfa;
      --point-color: #a78bfa;
      --header-bg: #020617;
      --header-text: #f8fafc;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-rows: auto 1fr;
      overflow: hidden;
      transition: background 0.3s, color 0.3s;
    }

    /* Header */
    header {
      padding: 0.5rem 1.25rem;
      border-bottom: 1px solid var(--border);
      background: var(--header-bg);
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 50px;
    }

    header h1 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      color: var(--header-text);
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .theme-toggle {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 0.4rem 0.75rem;
      color: var(--header-text);
      cursor: pointer;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      transition: background 0.2s;
    }

    .theme-toggle:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Main Layout */
    #app {
      display: grid;
      grid-template-columns: 420px 1fr;
      height: 100%;
      overflow: hidden;
    }

    /* Sidebar / Controls */
    #sidebar {
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--border);
      background: var(--bg);
      overflow: hidden;
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.5);
    }

    .tab {
      flex: 1;
      padding: 0.75rem;
      text-align: center;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-muted);
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .tab:hover {
      color: var(--text);
      background: rgba(255, 255, 255, 0.05);
    }

    .tab.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
      background: rgba(59, 130, 246, 0.1);
    }

    /* Tab Content */
    .tab-content {
      flex: 1;
      overflow-y: auto;
      padding: 1.25rem;
      display: none;
      flex-direction: column;
      gap: 1.5rem;
    }

    .tab-content.active {
      display: flex;
    }

    /* Generic UI Elements */
    .section {
      display: grid;
      gap: 0.5rem;
    }

    .section h2 {
      margin: 0;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .section h2::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border);
      opacity: 0.5;
    }

    label {
      display: block;
      font-size: 0.8rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .help {
      font-size: 0.75rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    /* Info Tooltips */
    .info-tip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid var(--text-muted);
      color: var(--text-muted);
      font-size: 0.6rem;
      font-weight: 700;
      cursor: help;
      position: relative;
      margin-left: 0.35rem;
    }

    .info-tip:hover::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 120%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-alt);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.65rem;
      font-size: 0.7rem;
      font-weight: 400;
      white-space: normal;
      width: 200px;
      line-height: 1.4;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    /* Strata Legend */
    .strata-legend {
      margin-top: 0.5rem;
      max-height: 120px;
      overflow-y: auto;
    }

    .strata-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem 0;
      font-size: 0.75rem;
    }

    .strata-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    .strata-label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .strata-count {
      color: var(--text-muted);
      font-size: 0.7rem;
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 0.5rem 0.6rem;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 0.85rem;
      font-family: inherit;
      transition: border 0.2s;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary);
    }

    .btn {
      width: 100%;
      padding: 0.6rem;
      border-radius: 6px;
      border: none;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: filter 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .btn:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn.primary {
      background: var(--primary);
      color: white;
    }

    .btn.accent {
      background: var(--accent);
      color: white;
    }

    .btn.good {
      background: var(--success);
      color: white;
    }

    .btn.outline {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .drop-zone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.02);
      transition: all 0.2s;
    }

    .drop-zone:hover {
      border-color: var(--primary);
      background: rgba(59, 130, 246, 0.05);
    }

    .drop-zone.active {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
    }

    /* Cards */
    .card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem;
    }

    .stats-val {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--text);
    }

    .stats-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    /* Details/Summary */
    details {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.2);
    }

    details summary {
      padding: 0.6rem;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      list-style: none;
    }

    details summary::-webkit-details-marker {
      display: none;
    }

    details[open] summary {
      border-bottom: 1px solid var(--border);
    }

    details .inner {
      padding: 0.75rem;
    }

    /* Tables for Analysis */
    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    .data-table th,
    .data-table td {
      padding: 0.4rem;
      border: 1px solid var(--border);
      text-align: center;
    }

    .data-table th {
      background: rgba(255, 255, 255, 0.05);
    }

    .data-table .row-header {
      text-align: left;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.02);
    }

    /* Map */
    #map {
      height: 100%;
      width: 100%;
      z-index: 1;
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15, 23, 42, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      flex-direction: column;
      gap: 1rem;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Charts */
    .chart-container {
      height: 100px;
      width: 100%;
      position: relative;
      border-bottom: 1px solid var(--border);
      border-left: 1px solid var(--border);
      margin-top: 10px;
    }

    .chart-bar {
      position: absolute;
      bottom: 0;
      background: var(--primary);
      opacity: 0.7;
      transition: height 0.3s;
    }

    .chart-label {
      position: absolute;
      bottom: -15px;
      font-size: 10px;
      color: var(--text-muted);
      transform: translateX(-50%);
    }
  </style>
</head>

<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
    <div class="help" id="loadingText">Processing...</div>
  </div>

  <header>
    <h1>Random GeoPoints</h1>
    <div class="header-actions">
      <button class="theme-toggle" id="themeToggle">
        <span id="themeIcon">ðŸŒ™</span>
        <span id="themeLabel">Dark</span>
      </button>
      <a href="https://github.com/sounny/randomgeopoints" target="_blank"
        style="color:var(--header-text); opacity:0.7; text-decoration:none; font-size:0.8rem">Docs</a>
    </div>
  </header>

  <div id="app">
    <div id="sidebar">
      <!-- Tabs -->
      <div class="tabs">
        <div class="tab active" data-tab="design">1. Design</div>
        <div class="tab" data-tab="protocol">2. Protocol</div>
        <div class="tab" data-tab="analyze">3. Analyze</div>
      </div>

      <!-- Tab 1: Design -->
      <div id="design" class="tab-content active">

        <!-- Sampling Method -->
        <div class="section">
          <h2>Sampling Method<span class="info-tip"
              data-tip="Probability-based designs ensure every location has a known, non-zero chance of selection (Olofsson 2014).">?</span>
          </h2>
          <select id="method">
            <optgroup label="Probabilistic (Unbiased)">
              <option value="uniform-bbox">Simple Random (BBox)</option>
              <option value="uniform-poly">Simple Random (Polygon)</option>
              <option value="balanced">Spatially Balanced (Halton)</option>
            </optgroup>
            <optgroup label="Stratified / Structured">
              <option value="stratified-prop">Stratified (Proportional)</option>
              <option value="stratified-equal">Stratified (Equal Allocation)</option>
              <option value="systematic">Systematic Grid</option>
              <option value="hex">Hexagonal Lattice</option>
            </optgroup>
            <optgroup label="Specialized">
              <option value="cluster">Cluster Sampling</option>
              <option value="plots">Random Plots (Square)</option>
            </optgroup>
          </select>
        </div>

        <!-- AOI -->
        <div class="section">
          <h2>Sampling Frame (AOI)<span class="info-tip"
              data-tip="The Area of Interest defines the population boundary. Points outside the AOI have zero probability of selection.">?</span>
          </h2>
          <div class="drop-zone" id="aoiDrop">
            <div>Drop AOI GeoJSON</div>
            <input type="file" id="aoiInput" accept=".json,.geojson" hidden>
          </div>
          <div class="grid2">
            <button class="btn outline" id="drawBtn">Draw BBox</button>
            <button class="btn outline" id="fitBtn">Fit Map</button>
          </div>
          <input type="hidden" id="bboxStr"> <!-- Hidden storage for bbox -->
        </div>

        <!-- Strata -->
        <div class="section" id="strataSection">
          <h2>Strata (Optional)<span class="info-tip"
              data-tip="Stratification improves precision by ensuring all land cover classes are sampled. Stratified designs can reduce variance by ~50% (Cochran 1977).">?</span>
          </h2>
          <div class="drop-zone" id="strataDrop">
            <div>Drop Strata GeoJSON</div>
            <input type="file" id="strataInput" accept=".json,.geojson" hidden>
          </div>
          <div id="strataControls" style="display:none; margin-top:0.5rem">
            <label>Strata Field</label>
            <select id="strataField"></select>
            <div id="strataLegend" class="strata-legend"></div>
            <div id="strataAllocation" style="margin-top:0.5rem"></div>
          </div>
        </div>

        <!-- Parameters -->
        <div class="section">
          <h2>Sample Size & Config<span class="info-tip"
              data-tip="n = (ZÂ² Ã— p Ã— q) / EÂ² where Z=1.96 (95% CI), p=expected accuracy, E=margin of error (Cochran 1977).">?</span>
          </h2>
          <div class="grid2">
            <div>
              <label>Target Size (n)</label>
              <input type="number" id="nPts" value="100" min="1">
            </div>
            <div>
              <label>Seed</label>
              <input type="text" id="seed" value="12345">
            </div>
          </div>

          <!-- Method specific options -->
          <div id="opt-grid" style="display:none">
            <label>Grid Cell (deg)</label>
            <input type="number" id="cellSize" step="0.001" value="0.02">
          </div>
          <div id="opt-cluster" style="display:none">
            <label>Clusters / Radius (m)</label>
            <div class="grid2">
              <input type="number" id="nClusters" value="10">
              <input type="number" id="clustRad" value="1000">
            </div>
          </div>
          <div id="opt-plots" style="display:none">
            <label>Plot Side (m)</label>
            <input type="number" id="plotSide" value="30">
          </div>

          <!-- Sample Size Calculator (Cochran 1977) -->
          <details style="margin-top:0.75rem">
            <summary>ðŸ“Š Sample Size Calculator</summary>
            <div class="inner">
              <p class="help" style="margin-bottom:0.5rem">Cochran's formula: n = ZÂ²pq / EÂ²</p>
              <div class="grid2">
                <div>
                  <label>Expected Accuracy (%)</label>
                  <input type="number" id="calcP" value="85" min="50" max="99">
                </div>
                <div>
                  <label>Margin of Error (%)</label>
                  <input type="number" id="calcE" value="5" min="1" max="20">
                </div>
              </div>
              <button class="btn outline" id="calcNBtn" style="margin-top:0.5rem;width:100%">Calculate â†’ Set n</button>
              <div id="calcResult" class="help" style="margin-top:0.35rem;text-align:center"></div>
            </div>
          </details>

          <!-- Power Analysis Visualizer -->
          <div class="card" style="margin-top:0.5rem">
            <div class="stats-label">Power Analysis (95% CI)<span class="info-tip"
                data-tip="Shows margin of error at different sample sizes assuming worst-case p=0.5 (maximum variance).">?</span>
            </div>
            <div class="chart-container" id="powerChart">
              <!-- Bars injected by JS -->
            </div>
            <div class="help" style="margin-top:5px; text-align:center">Margin of error at different n (p=0.5)</div>
          </div>
        </div>

        <button class="btn primary" id="genBtn">Generate Sample</button>

        <!-- Design Results -->
        <div class="section" id="designResults" style="display:none">
          <h2>Design Output</h2>
          <div class="card">
            <div class="grid2">
              <div>
                <div class="stats-label">Count</div>
                <div class="stats-val" id="resCount">-</div>
              </div>
              <div>
                <div class="stats-label">Density</div>
                <div class="stats-val" id="resDensity">-</div>
              </div>
            </div>
            <div style="margin-top:0.5rem">
              <div class="stats-label">Spatial Health</div>
              <div id="nniStat" style="font-weight:600">-</div>
            </div>
          </div>
          <div class="grid2">
            <button class="btn good" id="dlGeoBtn">GeoJSON</button>
            <button class="btn good" id="dlCsvBtn">CSV</button>
          </div>
        </div>

      </div>

      <!-- Tab 2: Protocol -->
      <div id="protocol" class="tab-content">
        <div class="section">
          <h2>Response Design Protocol</h2>
          <p class="help">Define rules for labeling to ensure consistency (Stehman & Czaplewski 1998).</p>

          <label>Minimum Mapping Unit (MMU)</label>
          <select id="protoMmu">
            <option>Single Pixel (Center)</option>
            <option>3x3 Pixel Block (Majority)</option>
            <option>Polygon/Object (Dominant)</option>
          </select>

          <label>Labeling Confidence Threshold</label>
          <select id="protoConf">
            <option>High (100% certainty only)</option>
            <option>Medium (Probable)</option>
            <option>Low (Best guess allowed)</option>
          </select>

          <label>Edge Case Rule</label>
          <textarea id="protoEdge" rows="3" placeholder="e.g. If point falls on boundary, shift North 5m..."></textarea>
        </div>

        <div class="section">
          <h2>Field Data Schema</h2>
          <label>Attributes to collect:</label>
          <div id="schemaList">
            <div class="card help">
              - plot_id (Auto)<br>
              - map_label (Pre-filled)<br>
              - ref_label (To Fill)<br>
              - confidence (To Fill)<br>
              - comments (To Fill)
            </div>
          </div>
        </div>

        <button class="btn accent" id="dlProtoBtn">Download Protocol PDF</button>
      </div>

      <!-- Tab 3: Analyze -->
      <div id="analyze" class="tab-content">
        <div class="section">
          <h2>Analysis Engine (Olofsson et al. 2014)</h2>
          <p class="help">Calculate rigorous accuracy metrics and area estimates.</p>

          <div class="drop-zone" id="resDrop">
            <div>Drop Labeled Results (CSV/GeoJSON)</div>
            <input type="file" id="resInput" accept=".csv,.json,.geojson" hidden>
          </div>

          <div id="colMapping" style="display:none" class="card">
            <label>Map Label Column</label>
            <select id="colMap"></select>
            <label>Reference Label Column</label>
            <select id="colRef"></select>
            <button class="btn primary" id="calcBtn" style="margin-top:0.5rem">Calculate Accuracy</button>
          </div>
        </div>

        <div id="analysisOut" style="display:none" class="section">
          <h2>Accuracy Results</h2>

          <div class="card">
            <div class="grid2">
              <div>
                <div class="stats-label">Overall Accuracy</div>
                <div class="stats-val" id="valOA">-</div>
              </div>
              <div>
                <div class="stats-label">Margin of Error</div>
                <div class="stats-val" id="valOASE">-</div>
              </div>
            </div>
          </div>

          <details open>
            <summary class="btn outline" style="margin-bottom:0.5rem">Confusion Matrix</summary>
            <div style="overflow-x:auto">
              <table class="data-table" id="matrixTable"></table>
            </div>
          </details>

          <details>
            <summary class="btn outline">Class Metrics (UA/PA)</summary>
            <div style="overflow-x:auto; margin-top:0.5rem">
              <table class="data-table" id="classTable">
                <thead>
                  <tr>
                    <th>Class</th>
                    <th>UA (User)</th>
                    <th>PA (Prod)</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </details>

        </div>
      </div>

    </div>

    <!-- Map Area -->
    <div id="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <script>
    /* =========================================
       THEME TOGGLE
       ========================================= */
    let updateMapTiles = () => { }; // Placeholder, will be set after map init

    const initTheme = () => {
      const saved = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = saved || (prefersDark ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', theme);
      updateThemeUI(theme);
    };

    const updateThemeUI = (theme) => {
      const icon = document.getElementById('themeIcon');
      const label = document.getElementById('themeLabel');
      if (theme === 'dark') {
        icon.textContent = 'â˜€ï¸';
        label.textContent = 'Light';
      } else {
        icon.textContent = 'ðŸŒ™';
        label.textContent = 'Dark';
      }
    };

    document.getElementById('themeToggle').addEventListener('click', () => {
      const current = document.documentElement.getAttribute('data-theme');
      const next = current === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
      localStorage.setItem('theme', next);
      updateThemeUI(next);
      // Switch map tiles (function defined after map init)
      updateMapTiles(next);
    });

    initTheme();

    /* =========================================
       CORE UTILITIES & STATE
       ========================================= */
    const state = {
      aoi: null,
      strata: null,
      sample: null,
      sampleMeta: {},
      analysisData: null
    };

    // Normalize any GeoJSON input into a FeatureCollection or return null
    const toFeatureCollection = (input) => {
      if (!input) return null;
      if (input.type === 'FeatureCollection') {
        if (!Array.isArray(input.features) || input.features.length === 0) return null;
        return input;
      }
      if (input.type === 'Feature') {
        return { type: 'FeatureCollection', features: [input] };
      }
      if (input.type && input.coordinates) {
        return { type: 'FeatureCollection', features: [{ type: 'Feature', geometry: input, properties: {} }] };
      }
      return null;
    };

    // Robust point-in-AOI helper that supports multi-feature collections
    const pointInAoi = (pt) => {
      if (!state.aoi?.features?.length) return false;
      return state.aoi.features.some(feature => {
        const geomType = feature?.geometry?.type;
        if (!geomType) return false;
        if (geomType === 'Polygon' || geomType === 'MultiPolygon') {
          return turf.booleanPointInPolygon(pt, feature);
        }
        return false;
      });
    };

    // Seeded RNG (Mulberry32)
    const seedRNG = (str) => {
      const s = (str ?? 'seed').toString();
      let h = 1779033703 ^ s.length;
      for (let i = 0; i < s.length; i++) {
        h = Math.imul(h ^ s.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return () => {
        let t = h += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    };

    // Simple Halton Sequence
    const halton = (idx, base) => {
      let result = 0, f = 1 / base, i = idx;
      while (i > 0) { result += f * (i % base); i = Math.floor(i / base); f /= base; }
      return result;
    };



    // Strata color palette (categorical, colorblind-friendly)
    const STRATA_COLORS = [
      '#2563eb', '#dc2626', '#16a34a', '#ca8a04', '#9333ea',
      '#0891b2', '#be185d', '#65a30d', '#ea580c', '#6366f1'
    ];
    const getStrataColor = (idx) => STRATA_COLORS[idx % STRATA_COLORS.length];

    // Nearest Neighbor Index calculation (Clark & Evans 1954)
    const calculateNNI = (points, areaSqM) => {
      if (!points || points.length < 10) return { nni: null, pattern: 'N/A' };
      const coords = points.map(p => p.geometry.coordinates);
      let sumNN = 0;
      // Sample up to 100 points for performance
      const sample = coords.length > 100 ? coords.filter((_, i) => i % Math.ceil(coords.length / 100) === 0) : coords;
      sample.forEach((c1, i) => {
        let minDist = Infinity;
        coords.forEach((c2, j) => {
          if (i !== j) {
            const d = turf.distance(turf.point(c1), turf.point(c2), { units: 'meters' });
            if (d < minDist) minDist = d;
          }
        });
        sumNN += minDist;
      });
      const obsAvg = sumNN / sample.length;
      const density = points.length / areaSqM;
      const expAvg = 0.5 / Math.sqrt(density);
      const nni = obsAvg / expAvg;
      let pattern = 'Random';
      if (nni < 0.8) pattern = 'Clustered';
      else if (nni > 1.2) pattern = 'Dispersed';
      return { nni: nni.toFixed(2), pattern };
    };

    // Analyze strata: get unique values, areas, and proportions
    const analyzeStrata = (fc, fieldName) => {
      if (!fc || !fc.features || !fieldName) return [];
      const strataMap = {};
      fc.features.forEach(f => {
        const val = f.properties?.[fieldName] ?? 'Unknown';
        if (!strataMap[val]) strataMap[val] = { name: val, features: [], areaSqM: 0 };
        strataMap[val].features.push(f);
        strataMap[val].areaSqM += turf.area(f);
      });
      const totalArea = Object.values(strataMap).reduce((s, v) => s + v.areaSqM, 0);
      return Object.values(strataMap).map((v, i) => ({
        ...v,
        color: getStrataColor(i),
        proportion: totalArea > 0 ? v.areaSqM / totalArea : 0
      }));
    };

    // Calculate allocation per stratum (Cochran 1977)
    const calculateAllocation = (strataInfo, totalN, mode = 'proportional') => {
      // Guard against undefined or empty strata
      if (!strataInfo || !Array.isArray(strataInfo) || strataInfo.length === 0) {
        return [];
      }
      if (mode === 'equal') {
        const nPer = Math.floor(totalN / strataInfo.length);
        let remainder = totalN - nPer * strataInfo.length;
        return strataInfo.map((s, i) => ({ ...s, n: nPer + (i < remainder ? 1 : 0) }));
      }
      // Proportional allocation: n_h = n * W_h
      let allocated = strataInfo.map(s => ({ ...s, n: Math.floor(totalN * s.proportion) }));
      let sum = allocated.reduce((a, b) => a + b.n, 0);
      let diff = totalN - sum;
      // Distribute remainder to largest strata
      allocated.sort((a, b) => b.proportion - a.proportion);
      for (let i = 0; i < diff; i++) allocated[i % allocated.length].n++;
      return allocated;
    };

    /* =========================================
       UI LOGIC
       ========================================= */

    // Tab Switching
    document.querySelectorAll('.tab').forEach(t => {
      t.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(x => x.classList.remove('active'));
        t.classList.add('active');
        document.getElementById(t.dataset.tab).classList.add('active');
        // Refresh map size on tab switch
        setTimeout(() => map.invalidateSize(), 100);
      });
    });

    // Method Options Visibility
    document.getElementById('method').addEventListener('change', (e) => {
      const m = e.target.value;
      document.getElementById('opt-grid').style.display = ['systematic', 'hex'].includes(m) ? 'block' : 'none';
      document.getElementById('opt-cluster').style.display = m === 'cluster' ? 'block' : 'none';
      document.getElementById('opt-plots').style.display = m === 'plots' ? 'block' : 'none';
    });
    // Trigger initial state
    document.getElementById('method').dispatchEvent(new Event('change'));

    // Sample Size Calculator (Cochran 1977)
    document.getElementById('calcNBtn').addEventListener('click', () => {
      const p = parseFloat(document.getElementById('calcP').value) / 100;
      const e = parseFloat(document.getElementById('calcE').value) / 100;
      if (p < 0.5 || p > 0.99 || e < 0.01 || e > 0.2) {
        document.getElementById('calcResult').innerHTML = '<span style="color:var(--danger)">Invalid inputs</span>';
        return;
      }
      const z = 1.96; // 95% CI
      const q = 1 - p;
      const n = Math.ceil((z * z * p * q) / (e * e));
      document.getElementById('nPts').value = n;
      document.getElementById('calcResult').innerHTML = `<strong>${n}</strong> samples needed for Â±${(e * 100).toFixed(0)}% at ${(p * 100).toFixed(0)}% accuracy`;
      updatePowerChart();
    });

    // Power Analysis Chart (Simple Canvas-less implementation)
    function updatePowerChart() {
      const n = parseInt(document.getElementById('nPts').value) || 100;
      const container = document.getElementById('powerChart');
      container.innerHTML = '';

      const steps = [0.5, 1, 2, 4]; // multipliers of n
      const baseMOE = (1.96 * Math.sqrt(0.25 / n)) * 100; // Worst case p=0.5

      steps.forEach((mult, i) => {
        const thisN = Math.round(n * mult);
        const moe = (1.96 * Math.sqrt(0.25 / thisN)) * 100;
        const heightPct = (moe / (1.96 * Math.sqrt(0.25 / 10) * 100)) * 100 * 3; // Scaling factor for vis

        const bar = document.createElement('div');
        bar.className = 'chart-bar';
        bar.style.height = Math.min(heightPct, 90) + '%';
        bar.style.left = (15 + i * 25) + '%';
        bar.style.width = '15%';

        const label = document.createElement('div');
        label.className = 'chart-label';
        label.innerHTML = `n=${thisN}<br>+/-${moe.toFixed(1)}%`;
        bar.appendChild(label);
        container.appendChild(bar);
      });
    }
    document.getElementById('nPts').addEventListener('input', updatePowerChart);
    updatePowerChart(); // Init

    /* =========================================
       MAP & DRAWING
       ========================================= */
    const map = L.map('map').setView([0, 0], 2);

    // Tile layers for light/dark themes
    const tileLayers = {
      light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap &copy; CARTO'
      }),
      dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap &copy; CARTO'
      })
    };

    // Set initial tile layer based on theme
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
    tileLayers[currentTheme].addTo(map);

    // Assign the real updateMapTiles function now that map is initialized
    updateMapTiles = (theme) => {
      map.eachLayer(layer => {
        if (layer instanceof L.TileLayer) map.removeLayer(layer);
      });
      tileLayers[theme].addTo(map);
    };

    const layers = {
      aoi: L.geoJSON(null, { style: { color: '#0d9488', weight: 2, fillOpacity: 0.1 } }).addTo(map),
      strata: L.geoJSON(null, { style: { color: '#d97706', weight: 1, fillOpacity: 0.15 } }).addTo(map),
      samples: L.geoJSON(null, {
        pointToLayer: (f, ll) => L.circleMarker(ll, {
          radius: 5,
          color: '#ffffff',
          weight: 1,
          fillColor: '#7c3aed',
          fillOpacity: 0.9
        }),
        style: { color: '#7c3aed', weight: 2, fillOpacity: 0.15 } // For plots
      }).addTo(map)
    };

    const drawControl = new L.Control.Draw({
      draw: { rectangle: true, polygon: false, circle: false, marker: false, polyline: false },
      edit: false
    });

    document.getElementById('drawBtn').addEventListener('click', () => {
      map.addControl(drawControl);
    });

    map.on(L.Draw.Event.CREATED, (e) => {
      const layer = e.layer;
      const gj = layer.toGeoJSON();
      state.aoi = toFeatureCollection({ type: 'FeatureCollection', features: [gj] });
      if (!state.aoi) { alert('Could not read drawn AOI'); return; }
      layers.aoi.clearLayers().addData(state.aoi);
      map.removeControl(drawControl);
      document.getElementById('aoiDrop').innerHTML = '<div>Custom bbox set</div>';
    });

    document.getElementById('fitBtn').addEventListener('click', () => {
      if (layers.aoi.getLayers().length) map.fitBounds(layers.aoi.getBounds());
    });

    /* =========================================
       FILE HANDLING
       ========================================= */
    const setupDrop = (id, inputId, cb) => {
      const el = document.getElementById(id);
      const inp = document.getElementById(inputId);
      el.onclick = () => inp.click();
      inp.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        cb(file, el);
      };
      el.ondragover = (e) => { e.preventDefault(); el.classList.add('active'); };
      el.ondragleave = () => el.classList.remove('active');
      el.ondrop = async (e) => {
        e.preventDefault(); el.classList.remove('active');
        const file = e.dataTransfer.files[0];
        if (!file) return;
        cb(file, el);
      };
    };

    setupDrop('aoiDrop', 'aoiInput', async (file, el) => {
      const txt = await file.text();
      const parsed = JSON.parse(txt);
      const fc = toFeatureCollection(parsed);
      if (!fc) { alert('AOI file must be a Polygon/MultiPolygon/FeatureCollection'); return; }
      state.aoi = fc;
      layers.aoi.clearLayers().addData(state.aoi);
      map.fitBounds(layers.aoi.getBounds());
      el.innerHTML = `<div>Loaded ${file.name}</div>`;
    });

    setupDrop('strataDrop', 'strataInput', async (file, el) => {
      const txt = await file.text();
      const parsed = JSON.parse(txt);
      const fc = toFeatureCollection(parsed);
      if (!fc) { alert('Strata file must be a valid FeatureCollection'); return; }
      state.strata = fc;
      layers.strata.clearLayers().addData(state.strata);
      el.innerHTML = `<div>Loaded ${file.name}</div>`;

      // Populate fields
      if (!state.strata.features.length) { alert('Strata file has no features'); return; }
      const props = Object.keys(state.strata.features[0].properties || {});
      const sel = document.getElementById('strataField');
      sel.innerHTML = '';
      props.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p; opt.text = p;
        sel.appendChild(opt);
      });
      document.getElementById('strataControls').style.display = 'block';

      // Build legend and update map styling
      updateStrataLegend();
    });

    // Strata field change handler
    document.getElementById('strataField').addEventListener('change', updateStrataLegend);

    function updateStrataLegend() {
      const fieldName = document.getElementById('strataField').value;
      if (!state.strata || !fieldName) return;

      const strataInfo = analyzeStrata(state.strata, fieldName);
      state.strataInfo = strataInfo;

      // Build color map
      const colorMap = {};
      strataInfo.forEach(s => { colorMap[s.name] = s.color; });

      // Update map layer styling
      layers.strata.clearLayers();
      layers.strata.options.style = (feature) => ({
        color: colorMap[feature.properties?.[fieldName]] || '#888',
        weight: 1.5,
        fillOpacity: 0.25
      });
      layers.strata.addData(state.strata);

      // Render legend
      const legendEl = document.getElementById('strataLegend');
      legendEl.innerHTML = strataInfo.map(s => `
        <div class="strata-legend-item">
          <div class="strata-swatch" style="background:${s.color}"></div>
          <span class="strata-label">${s.name}</span>
          <span class="strata-count">${(s.proportion * 100).toFixed(1)}%</span>
        </div>
      `).join('');
    }

    /* =========================================
       GENERATION LOGIC (Condensed)
       ========================================= */
    document.getElementById('genBtn').addEventListener('click', () => {
      const aoiFC = toFeatureCollection(state.aoi);
      if (!aoiFC) return alert('Please define an AOI first (Polygon or FeatureCollection).');
      state.aoi = aoiFC;

      const config = {
        n: parseInt(document.getElementById('nPts').value),
        seed: document.getElementById('seed').value,
        method: document.getElementById('method').value
      };

      document.getElementById('loadingOverlay').style.display = 'flex';

      // Simulate async for UI unblocking
      setTimeout(() => {
        try {
          const rng = seedRNG(config.seed);
          const bbox = turf.bbox(state.aoi);
          const points = [];

          // Core Generation Switch
          // Note: In a real "V2", these would be modular functions. Inline for brevity here.

          if (config.method.includes('uniform') || config.method === 'balanced') {
            // Simple / Balanced
            let tries = 0;
            let idx = 0;
            while (points.length < config.n && tries < config.n * 500) {
              tries++;
              let x, y;
              if (config.method === 'balanced') {
                idx++;
                x = bbox[0] + (bbox[2] - bbox[0]) * halton(idx, 2);
                y = bbox[1] + (bbox[3] - bbox[1]) * halton(idx, 3);
              } else {
                x = bbox[0] + (bbox[2] - bbox[0]) * rng();
                y = bbox[1] + (bbox[3] - bbox[1]) * rng();
              }
              const pt = turf.point([x, y]);
              if (pointInAoi(pt)) {
                points.push(pt);
              }
            }
          }
          else if (config.method === 'plots') {
            // Plot sampling logic
            const side = parseFloat(document.getElementById('plotSide').value);
            // ... logic similar to points but buffering ...
            // Simplified placeholder:
            let tries = 0;
            while (points.length < config.n && tries < config.n * 500) {
              tries++;
              const x = bbox[0] + (bbox[2] - bbox[0]) * rng();
              const y = bbox[1] + (bbox[3] - bbox[1]) * rng();
              const pt = turf.point([x, y]);
              if (pointInAoi(pt)) {
                // Create square
                const midLat = (bbox[1] + bbox[3]) / 2;
                const degX = side / (111320 * Math.cos(midLat * Math.PI / 180));
                const degY = side / 111320;
                points.push(turf.bboxPolygon([x - degX / 2, y - degY / 2, x + degX / 2, y + degY / 2]));
              }
            }
          }
          // Systematic Grid
          else if (config.method === 'systematic') {
            const cell = parseFloat(document.getElementById('cellSize').value) || 0.02;
            for (let x = bbox[0]; x <= bbox[2]; x += cell) {
              for (let y = bbox[1]; y <= bbox[3]; y += cell) {
                const pt = turf.point([x, y]);
                if (pointInAoi(pt)) points.push(pt);
              }
            }
          }
          // Hexagonal Lattice
          else if (config.method === 'hex') {
            const cell = parseFloat(document.getElementById('cellSize').value) || 0.02;
            const dy = cell * Math.sqrt(3) / 2;
            let row = 0;
            for (let y = bbox[1]; y <= bbox[3]; y += dy) {
              const xStart = bbox[0] + (row % 2 ? cell / 2 : 0);
              for (let x = xStart; x <= bbox[2]; x += cell) {
                const pt = turf.point([x, y]);
                if (pointInAoi(pt)) points.push(pt);
              }
              row++;
            }
          }
          // Cluster Sampling
          else if (config.method === 'cluster') {
            const nClusters = parseInt(document.getElementById('nClusters').value) || 10;
            const radius = parseFloat(document.getElementById('clustRad').value) || 1000;
            const centers = [];
            let tries = 0;
            while (centers.length < nClusters && tries < nClusters * 100) {
              tries++;
              const x = bbox[0] + (bbox[2] - bbox[0]) * rng();
              const y = bbox[1] + (bbox[3] - bbox[1]) * rng();
              const pt = turf.point([x, y]);
              if (pointInAoi(pt)) centers.push([x, y]);
            }
            const ptsPerCluster = Math.ceil(config.n / centers.length);
            centers.forEach((c, cIdx) => {
              for (let i = 0; i < ptsPerCluster && points.length < config.n; i++) {
                const midLat = (bbox[1] + bbox[3]) / 2;
                const mpdLon = 111320 * Math.cos(midLat * Math.PI / 180);
                const r = radius * Math.sqrt(rng());
                const theta = rng() * 2 * Math.PI;
                const nx = c[0] + (r * Math.cos(theta)) / mpdLon;
                const ny = c[1] + (r * Math.sin(theta)) / 111320;
                const candidate = turf.point([nx, ny], { cluster: cIdx + 1 });
                if (pointInAoi(candidate)) points.push(candidate);
              }
            });
          }
          // STRATIFIED SAMPLING (Proportional or Equal)
          else if (config.method.startsWith('stratified')) {
            const fieldName = document.getElementById('strataField').value;
            if (!state.strata || !fieldName) {
              throw new Error('Stratified sampling requires strata polygons. Please upload a strata file.');
            }
            const mode = config.method === 'stratified-equal' ? 'equal' : 'proportional';
            const strataInfo = state.strataInfo || analyzeStrata(state.strata, fieldName);
            const allocated = calculateAllocation(strataInfo, config.n, mode);

            if (!allocated || allocated.length === 0) {
              throw new Error('Could not allocate samples to strata. Check your strata file.');
            }

            allocated.forEach(stratum => {
              const stratumBbox = turf.bbox(turf.featureCollection(stratum.features));
              let tries = 0;
              let generated = 0;
              while (generated < stratum.n && tries < stratum.n * 500) {
                tries++;
                const x = stratumBbox[0] + (stratumBbox[2] - stratumBbox[0]) * rng();
                const y = stratumBbox[1] + (stratumBbox[3] - stratumBbox[1]) * rng();
                const pt = turf.point([x, y]);
                // Check if inside any polygon of this stratum
                const inside = stratum.features.some(f => turf.booleanPointInPolygon(pt, f));
                if (inside) {
                  pt.properties = {
                    stratum: stratum.name,
                    stratum_area_km2: (stratum.areaSqM / 1e6).toFixed(2),
                    stratum_weight: stratum.proportion.toFixed(4)
                  };
                  points.push(pt);
                  generated++;
                }
              }
            });
          }
          // Fallback - simple random
          else {
            let tries = 0;
            while (points.length < config.n && tries < config.n * 500) {
              tries++;
              const x = bbox[0] + (bbox[2] - bbox[0]) * rng();
              const y = bbox[1] + (bbox[3] - bbox[1]) * rng();
              const pt = turf.point([x, y]);
              if (pointInAoi(pt)) points.push(pt);
            }
          }

          // Update State
          state.sample = turf.featureCollection(points);

          // Add Metadata with design weights (Olofsson 2014)
          const totalArea = turf.area(state.aoi);
          state.sample.features.forEach((f, i) => {
            const baseWeight = 1 / points.length;
            f.properties = {
              id: i + 1,
              method: config.method,
              inclusion_prob: baseWeight.toFixed(6),
              weight: (1 / baseWeight).toFixed(2),
              ...f.properties
            };
          });

          // Add collection-level metadata
          state.sample.metadata = {
            generatedAt: new Date().toISOString(),
            seed: config.seed,
            method: config.method,
            targetN: config.n,
            actualN: points.length,
            aoiAreaKm2: (totalArea / 1e6).toFixed(2)
          };

          // Render
          layers.samples.clearLayers().addData(state.sample);

          // Update Stats
          const areaSqKm = totalArea / 1e6;
          document.getElementById('resCount').innerText = points.length;
          document.getElementById('resDensity').innerText = (points.length / areaSqKm).toFixed(2) + '/kmÂ²';

          // Spatial Health Check - Real NNI Calculation (Clark & Evans 1954)
          if (points.length >= 10 && points[0].geometry.type === 'Point') {
            document.getElementById('nniStat').innerText = "NNI: calculating...";
            setTimeout(() => {
              const nniResult = calculateNNI(points, totalArea);
              if (nniResult.nni) {
                document.getElementById('nniStat').innerText = `NNI: ${nniResult.nni} (${nniResult.pattern})`;
              } else {
                document.getElementById('nniStat').innerText = "NNI: N/A";
              }
            }, 50);
          } else {
            document.getElementById('nniStat').innerText = points[0]?.geometry?.type === 'Polygon' ? "N/A (Plots)" : "N/A (n<10)";
          }

          document.getElementById('designResults').style.display = 'block';
          document.getElementById('loadingOverlay').style.display = 'none';
        } catch (e) {
          alert('Error: ' + e.message);
          document.getElementById('loadingOverlay').style.display = 'none';
        }
      }, 100);
    });

    /* =========================================
       ANALYSIS LOGIC (Olofsson et al. 2014)
       ========================================= */
    setupDrop('resDrop', 'resInput', async (file, el) => {
      const txt = await file.text();
      let data = [];

      // Parse CSV or GeoJSON
      if (file.name.endsWith('json')) {
        const gj = JSON.parse(txt);
        data = gj.features.map(f => f.properties);
      } else {
        // Simple CSV parser
        const lines = txt.split('\n').map(l => l.trim()).filter(l => l);
        if (lines.length < 2) {
          alert('Result file needs a header row and at least one data row.');
          return;
        }
        const headers = lines[0].split(',');
        data = lines.slice(1).map(l => {
          const vals = l.split(',');
          let obj = {};
          headers.forEach((h, i) => obj[h] = vals[i]);
          return obj;
        });
      }

      if (!data.length) {
        alert('Result file did not contain any records.');
        return;
      }

      state.analysisData = data;
      el.innerHTML = `<div>Loaded ${data.length} records</div>`;

      // Populate Column Selects
      const cols = Object.keys(data[0] || {});
      if (!cols.length) {
        alert('Result file needs column headers.');
        return;
      }
      const populate = (id) => {
        const s = document.getElementById(id); s.innerHTML = '';
        cols.forEach(c => {
          const o = document.createElement('option');
          o.value = c; o.text = c;
          s.appendChild(o);
        });
      };
      populate('colMap'); populate('colRef');
      document.getElementById('colMapping').style.display = 'block';
    });

    document.getElementById('calcBtn').addEventListener('click', () => {
      const mapCol = document.getElementById('colMap').value;
      const refCol = document.getElementById('colRef').value;
      const data = state.analysisData;

      // 1. Build Confusion Matrix
      const classes = [...new Set([...data.map(d => d[mapCol]), ...data.map(d => d[refCol])])].sort();
      const matrix = {};
      classes.forEach(c => matrix[c] = {});

      let total = 0;
      let correct = 0;

      data.forEach(d => {
        const m = d[mapCol];
        const r = d[refCol];
        if (!matrix[m][r]) matrix[m][r] = 0;
        matrix[m][r]++;
        total++;
        if (m === r) correct++;
      });

      // 2. Render Matrix
      const table = document.getElementById('matrixTable');
      let html = '<thead><tr><th>Map \ Ref</th>';
      classes.forEach(c => html += `<th>${c}</th>`);
      html += '<th>Total</th></tr></thead><tbody>';

      classes.forEach(rowClass => {
        html += `<tr><td class="row-header">${rowClass}</td>`;
        let rowSum = 0;
        classes.forEach(colClass => {
          const val = matrix[rowClass][colClass] || 0;
          html += `<td>${val}</td>`;
          rowSum += val;
        });
        html += `<td><strong>${rowSum}</strong></td></tr>`;
      });
      html += '</tbody>';
      table.innerHTML = html;

      // 3. Calculate Olofsson Metrics (Simplified SRS assumption if weights not provided)
      // Note: Full Olofsson requires mapped area weights. 
      // V2 Implementation: Calculates raw sample-based metrics (Simple Random assumption)

      const oa = correct / total;
      const se = Math.sqrt((oa * (1 - oa)) / total); // Basic SE formula

      document.getElementById('valOA').innerText = (oa * 100).toFixed(2) + '%';
      document.getElementById('valOASE').innerText = '+/-' + (se * 1.96 * 100).toFixed(2) + '%';

      // Per Class Metrics
      const classBody = document.querySelector('#classTable tbody');
      classBody.innerHTML = '';

      classes.forEach(c => {
        // Row Sum (Mapped Total)
        let n_i_plus = 0;
        classes.forEach(k => n_i_plus += (matrix[c][k] || 0));

        // Col Sum (Ref Total)
        let n_plus_j = 0;
        classes.forEach(k => n_plus_j += (matrix[k][c] || 0));

        const correct_c = matrix[c][c] || 0;

        const ua = n_i_plus > 0 ? correct_c / n_i_plus : 0;
        const pa = n_plus_j > 0 ? correct_c / n_plus_j : 0;

        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${c}</td><td>${(ua * 100).toFixed(1)}%</td><td>${(pa * 100).toFixed(1)}%</td>`;
        classBody.appendChild(tr);
      });

      document.getElementById('analysisOut').style.display = 'block';
    });

    /* =========================================
       EXPORTS
       ========================================= */
    const download = (content, name, mime) => {
      const blob = new Blob([content], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = name;
      a.click(); URL.revokeObjectURL(url);
    };

    document.getElementById('dlGeoBtn').addEventListener('click', () => {
      if (!state.sample) return alert('Generate a sample first');
      const exportData = {
        ...state.sample,
        metadata: {
          generated: new Date().toISOString(),
          seed: document.getElementById('seed').value,
          method: document.getElementById('method').value,
          count: state.sample.features.length
        }
      };
      download(JSON.stringify(exportData, null, 2), 'sample.geojson', 'application/geo+json');
    });

    document.getElementById('dlCsvBtn').addEventListener('click', () => {
      if (!state.sample) return alert('Generate a sample first');
      const rows = [['id', 'lon', 'lat', 'method']];
      state.sample.features.forEach(f => {
        if (f.geometry.type === 'Point') {
          rows.push([f.properties.id, f.geometry.coordinates[0], f.geometry.coordinates[1], f.properties.method]);
        } else {
          const center = turf.centroid(f);
          rows.push([f.properties.id, center.geometry.coordinates[0], center.geometry.coordinates[1], f.properties.method]);
        }
      });
      download(rows.map(r => r.join(',')).join('\n'), 'sample.csv', 'text/csv');
    });

    document.getElementById('dlProtoBtn').addEventListener('click', () => {
      const txt = `
FIELD PROTOCOL - Generated by Random GeoPoints v2
-------------------------------------------------
Date: ${new Date().toISOString()}

1. SAMPLING DESIGN
   Target N: ${document.getElementById('nPts').value}
   Method: ${document.getElementById('method').value}

2. RESPONSE DESIGN
   Minimum Mapping Unit: ${document.getElementById('protoMmu').value}
   Confidence Threshold: ${document.getElementById('protoConf').value}
   
   Edge Rule:
   ${document.getElementById('protoEdge').value || 'None defined.'}

3. DATA DICTIONARY
   - map_label: The class from the map being validated.
   - ref_label: The ground truth class observed.
   - confidence: High/Med/Low.
      `;
      download(txt, 'protocol.txt', 'text/plain');
    });

  </script>
</body>

</html>
